= C++

:toc: auto
:source-highlighter: highlight.js

== C++ Style Guide

https://google.github.io/styleguide/cppguide.html[Google Style Guide]

== Basic Program

[,cpp]
----
#include <iostream>

int main() {
  
  std::cout << "Hello World!\n";
  return 0;

}
----

== Compile and Execute

To compile a simple `.cpp` file alone to `a.out`, you can run:

[,bash]
----
g++ hello.cpp
./a.out
----

Example:

[,console]
----
➜  simple1 g++ hello.cpp
➜  simple1 ls
a.out  hello.cpp
➜  simple1 ./a.out
Hello World
----

To compile our `.cpp` file to binary and give it a name:

[,bash]
----
g++ hello.cpp -o hello
----

A compiler translates the C++ program into machine language code which it stores on the disk as a file with the extension `.o` (e.g. `hello.o`). A linker then links the object code with standard library routines that the program may use and creates an executable image which is also saved on disk, usually as a file with the file name without any extension (e.g. `hello`).


== C++ Data Types

https://www.codecademy.com/resources/docs/cpp/data-types?page_ref=catalog[Types Catalog]

=== Datatype Modifiers

As the name implies, datatype modifiers are used with built-in data types to modify the length of data that a particular data type can hold. Data type modifiers in C++ are:

* `signed`
* `unsigned`
* `short`
* `long`

=== Const

`const` (constant) variables cannot be changed by your program during execution.

[,cpp]
----
const double quarter = 0.25;
// and now variable quarter can only be 0.25
----

Simply add the keyword `const` before the data type during declaration to make the variable not modifiable.

=== Type Conversion

A type cast is basically a conversion from one type to another.

The notation `(type) value` means "convert value to type". So for example:

[,cpp]
----
double weight1;
int weight2;

weight1 = 154.49;
weight2 = (int) weight1;

// weight2 is now 154
----

NOTE: Going from a `double` to an `int` simply removes the decimal. There's no rounding involved.


== Reading User Input

[,cpp]
----
#include <iostream>

int main() {
  
  int tip = 0;
  std::cout << "Enter tip amount: ";
  std::cin >> tip;

  std::cout << "You paid " << tip << " dollars.\n";

  return 0;

}
----

== Conditionals

Example random number generator program with `if`/`else` blocks.

[,cpp]
----
#include <iostream>
#include <stdlib.h>
#include <ctime>

int main() {
  
  // Create a number that's 0 or 1
  
  srand (time(NULL));
  int coin = rand() % 2;
  
  // If number is 0: Heads
  // If it is not 0: Tails  
  if (coin == 0) {
    std::cout << "Heads\n";
  }
  else {
    std::cout << "Tails\n";
  }
  
}
----

=== Switch Statements

Example program with switch statements. If you don't include the `break` for a condition, it will execute that block and "fall through" to the next one.

[,cpp]
----
#include <iostream>

int main() {
  
  int number = 9;
  
  switch(number) {
    
    case 1 :
      std::cout << "Bulbusaur\n";
      break;
    case 2 :
      std::cout << "Ivysaur\n";
      break;
    case 3 :
      std::cout << "Venusaur\n";
      break;
    case 4 :
      std::cout << "Charmander\n";
      break;
    case 5 :
      std::cout << "Charmeleon\n";
      break;
    case 6 :
      std::cout << "Charizard\n";
      break;
    default :
      std::cout << "Unknown\n";
      break;
  
  }
  
}
----

== Loops

Repeat instructions while some condition is met.

=== While Loops

Example `enter_pin.cpp` program using a `while` loop:

[,cpp]
----
#include <iostream>

int main() {
  
  int pin = 0;
  int tries = 0;
  
  std::cout << "BANK OF CODECADEMY\n";
  
  std::cout << "Enter your PIN: ";
  std::cin >> pin;

  tries++;

  while (pin != 1234 && tries < 3) {
    
    std::cout << "Enter your PIN: ";
    std::cin >> pin;
    tries++;
    
  }
  
  if (pin == 1234) {
    
    std::cout << "PIN accepted!\n";
    std::cout << "You now have access.\n"; 
    
  }
  
}
----

=== For Loops

Structure: `for (int i = 0; i < 20; i++)`:

* 3 parts: `( <initialization> ; <condition> ; <action> )`

Example:

[,cpp]
----
for (int i = 99; i >= 0; i--) {
    std::cout << i << " bottles of beer on the wall...\n";
}
----

== Errors

In C++, there are many different ways of classifying errors, but they can be boiled down to four categories:

* *Compile-time errors*: Errors found by the compiler.
* *Link-time errors*: Errors found by the linker when it is trying to combine object files into an executable program.
* *Run-time errors*: Errors found by checks in a running program.
* *Logic errors*: Errors found by the programmer looking for the causes of erroneous results.

=== Compile-time Errors

There are two types of compile-time errors:

* *Syntax errors*: Errors that occur when we violate the rules of C++ syntax.
* *Type errors*: Errors that occur when there are mismatch between the types we declared.

=== Link-time Errors

Sometimes the code compiles fine, but there is still a message because the program needs some function or library that it can't find. This is known as a link-time error.

As our program gets bigger, it is good practice to divide the program into separate files. After compiling them, the linker takes those separate object files and combines them into a single executable file. Link-time errors are found by the linker when it is trying to combine object files into an executable file.

=== Run-time Errors

If our program has no compile-time errors and no link-time errors, it'll run. This is where the fun really starts.

Errors which happen during program execution (run-time) after successful compilation are called run-time errors. Run-time errors occur when a program with no compile-time errors and link-time errors asks the computer to do something that the computer is unable to reliably do.

Some common run-time errors:

* Division by zero also known as division error. These types of error are hard to find as the compiler doesn't point to the line at which the error occurs.
* Trying to open a file that doesn't exist

=== Logic Errors

Once we have removed the compile-time errors, link-time errors, and run-time errors, the program runs successfully. But sometimes, the program doesn't do what we want it to do or no output is produced. Hmmm…

These types of errors which provide incorrect output, but appears to be error-free, are called logical errors. These are one of the most common errors that happen to beginners and also usually the most difficult to find and eliminate.

Logical errors solely depend on the logical thinking of the programmer. Your job now is to figure out why the program didn't do what you wanted it to do.

Some common logic errors:

* Program logic is flawed
* Some “silly” mistake in an if statement or a for/while loop

== Data Structures

=== Arrays

Reference: https://cplusplus.com/doc/tutorial/arrays/[arrays]

Fixed-size sequential data structure; lower-level than vectors.

==== Initialization

Allocate an empty array of type `int`, and size 4:

[,cpp]
----
int nums[4];
----

Initializing with values:

[,cpp]
----
// Equivalent statements
int nums[] = {1, 2, 3, 4};
int nums[] {1, 2, 3, 4};

// Create array of size 7, assign the first 4
// values, then the rest leave as default values
int nums[7] = {1, 2, 3, 4};
----

==== Accessing Array Elements

Use square brackets and an index to access values.

[,cpp]
----
nums[0] = 53;
std::cout << nums[0] << "\n";
----

==== Multi-dimensional Arrays

You can create arrays of arrays, i.e. matrices:

[,cpp]
----
// Create an array of 3 rows, 5 columns
int nums[3][5];

// Set the second row, third column to 7
nums[1][2] = 7;
----

=== Vectors

Essentially resizable arrays with built-in functions for manipulation, metadata, and safety checking.

Reference: https://cplusplus.com/reference/vector/vector/[vector]

==== Initialization

A `vector` is a sequence of elements that you can access by index. 

Include `<vector>` then declare it like: `std::vector<type> name;`

[,cpp]
----
#include <iostream>
#include <vector>

int main() {
   
  # Declare vector of doubles
  std::vector<double> subway_adult;

}
----

You can initialize a `vector` by assigning values at the same time as declaration, like you would with an array.

[,cpp]
----
std::vector<double> location = {42.651443, -73.749302};
----

or,

[,cpp]
----
std::vector<double> location{42.651443, -73.749302};
----

or,

[,cpp]
----
std::vector<double> location(2);
location[0] = 42.651443;
location[1] = -73.749302;
----

There's many ways to initialize a C++ `vector`. Check out this article to see more ways:

* https://www.geeksforgeeks.org/initialize-a-vector-in-cpp-different-ways/#[Different ways to initialize a CPP vector]

==== Accessing Vector Elements

Using square brackets:

[,cpp]
----
std::vector<double> location{42.651443, -73.749302};
std::cout << location[1] << "\n";
----

This doesn't prevent you from accessing elements outside the indices range of the vector. For example, one could use `location[5]`, which would take the beginning
of `location`, add 5 `double`-sized spaces, then use whatever is there in memory.

Using `.at()` function for safety/bounds checking:

[,cpp]
----
std::vector<double> location{42.651443, -73.749302};
std::cout << location.at(1) << "\n";
----

This makes sure that the index you passed in is within the bounds of the size of the vector. This is an example of an error thrown when going out of bounds.

[,console]
----
terminate called after throwing an instance of 'std::out_of_range'
  what():  vector::_M_range_check: __n (which is 4) >= this->size() (which is 3)
[1]    17482 abort (core dumped)  ./a.out
----

==== Adding and Removing Elements

`.push_back()` adds a new element to the end of the array:

[,cpp]
----
std::vector<std::string> last_jedi;
last_jedi.push_back("kylo");
----

`.pop_back()` removes an element from the end of the array:

[,cpp]
----
std::vector<std::string> last_jedi{"kylo", "rey"};
last_jedi.pop_back();
----

`.pop_back()` has no return value.

==== Viewing Size

The `.size()` function returns the number of elements in the vector.



