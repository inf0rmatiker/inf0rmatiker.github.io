= C++

:toc: auto
:source-highlighter: highlight.js

== C++ Style Guide

https://google.github.io/styleguide/cppguide.html[Google Style Guide]

== Basic Program

[,cpp]
----
#include <iostream>

int main() {
  
  std::cout << "Hello World!\n";
  return 0;

}
----

== Compile and Execute

To compile a simple `.cpp` file alone to `a.out`, you can run:

[,bash]
----
g++ hello.cpp
./a.out
----

Example:

[,console]
----
➜  simple1 g++ hello.cpp
➜  simple1 ls
a.out  hello.cpp
➜  simple1 ./a.out
Hello World
----

To compile our `.cpp` file to binary and give it a name:

[,bash]
----
g++ hello.cpp -o hello
----

A compiler translates the C++ program into machine language code which it stores on the disk as a file with the extension `.o` (e.g. `hello.o`). A linker then links the object code with standard library routines that the program may use and creates an executable image which is also saved on disk, usually as a file with the file name without any extension (e.g. `hello`).


== C++ Data Types

https://www.codecademy.com/resources/docs/cpp/data-types?page_ref=catalog[Types Catalog]

=== Datatype Modifiers

As the name implies, datatype modifiers are used with built-in data types to modify the length of data that a particular data type can hold. Data type modifiers in C++ are:

* `signed`
* `unsigned`
* `short`
* `long`

=== Const

`const` (constant) variables cannot be changed by your program during execution.

[,cpp]
----
const double quarter = 0.25;
// and now variable quarter can only be 0.25
----

Simply add the keyword `const` before the data type during declaration to make the variable not modifiable.

=== Type Conversion

A type cast is basically a conversion from one type to another.

The notation `(type) value` means "convert value to type". So for example:

[,cpp]
----
double weight1;
int weight2;

weight1 = 154.49;
weight2 = (int) weight1;

// weight2 is now 154
----

NOTE: Going from a `double` to an `int` simply removes the decimal. There's no rounding involved.


== Reading User Input

[,cpp]
----
#include <iostream>

int main() {
  
  int tip = 0;
  std::cout << "Enter tip amount: ";
  std::cin >> tip;

  std::cout << "You paid " << tip << " dollars.\n";

  return 0;

}
----

== Conditionals

Example random number generator program with `if`/`else` blocks.

[,cpp]
----
#include <iostream>
#include <stdlib.h>
#include <ctime>

int main() {
  
  // Create a number that's 0 or 1
  
  srand (time(NULL));
  int coin = rand() % 2;
  
  // If number is 0: Heads
  // If it is not 0: Tails  
  if (coin == 0) {
    std::cout << "Heads\n";
  }
  else {
    std::cout << "Tails\n";
  }
  
}
----

=== Switch Statements

Example program with switch statements. If you don't include the `break` for a condition, it will execute that block and "fall through" to the next one.

[,cpp]
----
#include <iostream>

int main() {
  
  int number = 9;
  
  switch(number) {
    
    case 1 :
      std::cout << "Bulbusaur\n";
      break;
    case 2 :
      std::cout << "Ivysaur\n";
      break;
    case 3 :
      std::cout << "Venusaur\n";
      break;
    case 4 :
      std::cout << "Charmander\n";
      break;
    case 5 :
      std::cout << "Charmeleon\n";
      break;
    case 6 :
      std::cout << "Charizard\n";
      break;
    default :
      std::cout << "Unknown\n";
      break;
  
  }
  
}
----

== Loops

Repeat instructions while some condition is met.

=== While Loops

Example `enter_pin.cpp` program using a `while` loop:

[,cpp]
----
#include <iostream>

int main() {
  
  int pin = 0;
  int tries = 0;
  
  std::cout << "BANK OF CODECADEMY\n";
  
  std::cout << "Enter your PIN: ";
  std::cin >> pin;

  tries++;

  while (pin != 1234 && tries < 3) {
    
    std::cout << "Enter your PIN: ";
    std::cin >> pin;
    tries++;
    
  }
  
  if (pin == 1234) {
    
    std::cout << "PIN accepted!\n";
    std::cout << "You now have access.\n"; 
    
  }
  
}
----

=== For Loops

Structure: `for (int i = 0; i < 20; i++)`:

* 3 parts: `( <initialization> ; <condition> ; <action> )`

Example:

[,cpp]
----
for (int i = 99; i >= 0; i--) {
    std::cout << i << " bottles of beer on the wall...\n";
}
----

== Errors

In C++, there are many different ways of classifying errors, but they can be boiled down to four categories:

* *Compile-time errors*: Errors found by the compiler.
* *Link-time errors*: Errors found by the linker when it is trying to combine object files into an executable program.
* *Run-time errors*: Errors found by checks in a running program.
* *Logic errors*: Errors found by the programmer looking for the causes of erroneous results.

=== Compile-time Errors

There are two types of compile-time errors:

* *Syntax errors*: Errors that occur when we violate the rules of C++ syntax.
* *Type errors*: Errors that occur when there are mismatch between the types we declared.

=== Link-time Errors

Sometimes the code compiles fine, but there is still a message because the program needs some function or library that it can't find. This is known as a link-time error.

As our program gets bigger, it is good practice to divide the program into separate files. After compiling them, the linker takes those separate object files and combines them into a single executable file. Link-time errors are found by the linker when it is trying to combine object files into an executable file.

=== Run-time Errors

If our program has no compile-time errors and no link-time errors, it'll run. This is where the fun really starts.

Errors which happen during program execution (run-time) after successful compilation are called run-time errors. Run-time errors occur when a program with no compile-time errors and link-time errors asks the computer to do something that the computer is unable to reliably do.

Some common run-time errors:

* Division by zero also known as division error. These types of error are hard to find as the compiler doesn't point to the line at which the error occurs.
* Trying to open a file that doesn't exist

=== Logic Errors

Once we have removed the compile-time errors, link-time errors, and run-time errors, the program runs successfully. But sometimes, the program doesn't do what we want it to do or no output is produced. Hmmm…

These types of errors which provide incorrect output, but appears to be error-free, are called logical errors. These are one of the most common errors that happen to beginners and also usually the most difficult to find and eliminate.

Logical errors solely depend on the logical thinking of the programmer. Your job now is to figure out why the program didn't do what you wanted it to do.

Some common logic errors:

* Program logic is flawed
* Some “silly” mistake in an if statement or a for/while loop

== Data Structures

=== Arrays

Reference: https://cplusplus.com/doc/tutorial/arrays/[arrays]

Fixed-size sequential data structure; lower-level than vectors.

==== Initialization

Allocate an empty array of type `int`, and size 4:

[,cpp]
----
int nums[4];
----

Initializing with values:

[,cpp]
----
// Equivalent statements
int nums[] = {1, 2, 3, 4};
int nums[] {1, 2, 3, 4};

// Create array of size 7, assign the first 4
// values, then the rest leave as default values
int nums[7] = {1, 2, 3, 4};
----

==== Accessing Array Elements

Use square brackets and an index to access values.

[,cpp]
----
nums[0] = 53;
std::cout << nums[0] << "\n";
----

==== Multi-dimensional Arrays

You can create arrays of arrays, i.e. matrices:

[,cpp]
----
// Create an array of 3 rows, 5 columns
int nums[3][5];

// Set the second row, third column to 7
nums[1][2] = 7;
----

=== Vectors

Essentially resizable arrays with built-in functions for manipulation, metadata, and safety checking.

Reference: https://cplusplus.com/reference/vector/vector/[vector]

==== Initialization

A `vector` is a sequence of elements that you can access by index. 

Include `<vector>` then declare it like: `std::vector<type> name;`

[,cpp]
----
#include <iostream>
#include <vector>

int main() {
   
  # Declare vector of doubles
  std::vector<double> subway_adult;

}
----

You can initialize a `vector` by assigning values at the same time as declaration, like you would with an array.

[,cpp]
----
std::vector<double> location = {42.651443, -73.749302};
----

or,

[,cpp]
----
std::vector<double> location{42.651443, -73.749302};
----

or,

[,cpp]
----
std::vector<double> location(2);
location[0] = 42.651443;
location[1] = -73.749302;
----

There's many ways to initialize a C++ `vector`. Check out this article to see more ways:

* https://www.geeksforgeeks.org/initialize-a-vector-in-cpp-different-ways/#[Different ways to initialize a CPP vector]

==== Accessing Vector Elements

Using square brackets:

[,cpp]
----
std::vector<double> location{42.651443, -73.749302};
std::cout << location[1] << "\n";
----

This doesn't prevent you from accessing elements outside the indices range of the vector. For example, one could use `location[5]`, which would take the beginning
of `location`, add 5 `double`-sized spaces, then use whatever is there in memory.

Using `.at()` function for safety/bounds checking:

[,cpp]
----
std::vector<double> location{42.651443, -73.749302};
std::cout << location.at(1) << "\n";
----

This makes sure that the index you passed in is within the bounds of the size of the vector. This is an example of an error thrown when going out of bounds.

[,console]
----
terminate called after throwing an instance of 'std::out_of_range'
  what():  vector::_M_range_check: __n (which is 4) >= this->size() (which is 3)
[1]    17482 abort (core dumped)  ./a.out
----

==== Adding and Removing Elements

`.push_back()` adds a new element to the end of the array:

[,cpp]
----
std::vector<std::string> last_jedi;
last_jedi.push_back("kylo");
----

`.pop_back()` removes an element from the end of the array:

[,cpp]
----
std::vector<std::string> last_jedi{"kylo", "rey"};
last_jedi.pop_back();
----

`.pop_back()` has no return value.

==== Viewing Size

The `.size()` function returns the number of elements in the vector.

== Functions

Structure is as follows:

----
return_type function_name(<params>) {

   // Code block here
   return output_if_there_is_any;

}
----

Example:

[,cpp]
----
std::string always_blue() {
  return "blue!\n";
}
----

== Macros

You can define macros to do things like logging, similar 
to aliases in bash. The compiler will replace these instances in
the code with whatever you defined in the macro.

[,cpp]
----
#define LOG(x) std::cout << x << std::endl

// Then, use it in code
int myvar = 3;
LOG(myvar);
----

== Pointers

Pointers are just integers that represent memory addresses.

=== Raw Pointers

https://www.youtube.com/watch?v=DTxHyVn0ODg&ab_channel=TheCherno[Pointers in C++]

==== Defining Pointers

A pointer is _just a memory address_ -- an integer, so it 
doesn't need a type. Giving a pointer a type
just states that the data at that address is the type
we specified.

Here we've defined a pointer with memory address `0`.
Note that `0` is not a valid memory address. It's
the same as `NULL`. 

[,cpp]
----
// These are all equivalent
void *ptr = 0;
void *ptr = NULL;
void *ptr = nullptr;
----

What if we want to create a useful pointer that points to
a valid memory address, like a variable in our program?

[,cpp]
----
int var = 16;

// &var is the memory address of var.
// int * is our way of telling what the data type is that
// ptr points to. Using void * would also be valid.
int *ptr = &var;
----

==== Using Pointers

We can use a pointer to manipulate the data stored at its 
address, by _dereferencing_ the pointer using a `*`.

Using the snippet above as an example:

[,cpp]
----
int var = 16;
int *ptr = &var;

// Writing from a pointer:
// Go to the address stored in ptr and set the value there to 13
*ptr = 13;

// Reading from a pointer:
// Retrieve the value at the address stored in ptr, save to myvar2
int myvar2 = *ptr;
----

We can allocate space on the heap, which returns a pointer to
the beginning address, set all the values to 0, then clean up.

[,cpp]
----
// Allocate 8 chars in heap, and return a pointer to first one
char *buffer = new char[8];

// Sweep 8 bytes starting at buffer and set each value to 0.
memset(buffer, 0, 8);

// Clean up allocated memory.
delete[] buffer;
----


==== Double, Triple Pointers

Pointers themselves are stored in memory, and have a 
memory address of their own. You can create a pointer
whose memory address references that of another pointer. 
These are essentially just pointers to pointers.

An example of this:

[,cpp]
----
int var = 16;

// Just like before, ptr1 is an int pointer
int *ptr1 = &var;

// Store address of ptr1 in ptr2
// ptr2 is a pointer to an int pointer, hence int **
int **ptr2 = &ptr1;
----

=== Smart Pointers

https://www.youtube.com/watch?v=UOB7-B2MfwA&ab_channel=TheCherno[Smart Pointers in C++]

Smart pointers are a way to automate the process of allocating and freeing memory on the heap. 
They're just a wrapper around a raw pointer.

With raw pointers, we would need to do:

[,cpp]
----
// Allocate 8 chars in heap, and return a pointer to first one
char *buffer = new char[8];

// ... do something with buffer ...

// Clean up allocated memory.
delete[] buffer;
----

Different types of smart pointers:

* `std::unique_ptr`: When this pointer goes out of scope, it will be destroyed (`delete` will be called on it). These are scoped, so you can't copy a `unique_ptr`, because when one copy of it dies, that memory is freed so all other copies just reference freed memory.
* 

==== Using Smart Pointers

https://www.geeksforgeeks.org/smart-pointers-cpp/#[GeeksForGeeks - Smart Pointers]

The first thing we'll have to do to get access to these smart pointers is to `#include <memory>`.

We'll be using the following class to demonstrate the
functionality of smart pointers:

[,cpp]
----
#include <iostream>
#include <string>
#include <memory>

// Class to show creation/destruction of smart pointer
class Entity {
    public:
    
        // Constructor
        Entity() {
            std::cout << "Created Entity!\n"; 
        }
    
        // Destructor
        ~Entity() {
            std::cout << "Destroyed Entity!\n";
        }
        
        void entityPrint() {
            std::cout << "print() invoked\n";
        }
};
----

--- 

`std::unique_ptr`

If we want to create a pointer that lives in a certain scope, we can do that like so:

[,cpp]
----
int main() {
    {
        std::unique_ptr<Entity> entity = std::make_unique<Entity>();
        
        entity->entityPrint();
    }
}
----

NOTE: You can only have *1* copy in existence for the life of a `std::unique_ptr`. Its life and death is within the scope that it was defined in. For example, you cannot do something like
`std::unique_ptr<Entity> e2 = entity`, this would not even compile.

---

`std::shared_ptr`

By using `shared_ptr`, more than one pointer can point 
to this one object at a time and it’ll maintain a 
Reference Counter using the `use_count()` method
(GeeksForGeeks). 
Each time a shared pointer falls out of scope, 
the allocated object's reference counter is decremented.
Once the reference count reaches zero, the object is
deallocated and freed.

Example:

[,cpp]
----
int main() {

    std::shared_ptr<Entity> e2;
    {
        std::shared_ptr<Entity> e1 = std::make_shared<Entity>();
        std::cout << e1.use_count() << '\n';
        e2 = e1;
        e2->entityPrint();
        std::cout << e2.use_count() << '\n';
    }
    std::cout << e2.use_count() << '\n';
}
----

Example output:

[,console]
----
Entity constructed()
1
print() invoked
2
1
Entity destructed()
----

== References

* https://www.youtube.com/watch?v=IzoFn3dfsPA&ab_channel=TheCherno[References in C++]
* https://www.geeksforgeeks.org/references-in-cpp/#[GeeksForGeeks - References]

A reference variable is a reference to an existing variable. 
When a variable is declared as a reference, it 
becomes an alternative name, or an alias, for an 
existing variable.
A variable can be declared as a reference by putting `&` in 
the declaration (GeeksForGeeks).

Example:

[,cpp]
----
int x = 10;
 
// ref is a reference to x.
// Now how you put "&" as part of type.
int& ref = x;

// Value of x is now changed to 20
ref = 20;
cout << "x = " << x << '\n';

// Value of x is now changed to 30
x = 30;
cout << "ref = " << ref << '\n';

return 0;
----

This does not create a new variable on the stack, 
like you would if you used a pointer. It's essentially the 
same variable, just by a different name.

=== Pass-by-copy vs. Pass-by-reference

Consider the following two functions:

[,cpp]
----
void increment(int val) {
    val++;
}

int main() {
    int a = 5;
    increment(a);
    std::cout << a << '\n';
}
----

Here the `increment` function only increments _its copy_ of 
`val`, not the original `a`. This is because the value 
of `a` was copied into the increment function instead of being
passed in by reference.


To pass by reference, we can change the parameter to a reference type `&int`. The compiler will handle converting `val` to an alias of `a`.

[,cpp]
----
void increment(int& val) {
    val++;
}

int main() {
    int a = 5;
    increment(a);
    std::cout << a << '\n';
}
----

== Structures

https://www.geeksforgeeks.org/structures-in-cpp/[GeeksForGeeks - Structures in C++]

A `struct` is more or less a grouping of variables, and is defined like:

[,cpp]
----
// -------- Option 1 ----------
struct Point {
   int x, y;
} p1;  // The variable p1 is declared with 'Point'
// -------- Option 2 ----------
// Delared without initializing a variable to it.
struct Point {
   int x;
   int y;
};

int main() {
    // You can initialize a variable after the struct definition.
    struct Point p1;
}
----