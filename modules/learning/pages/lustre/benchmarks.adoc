= Lustre Filesystem Benchmarks

:toc: auto
:showtitle:

== FIO

https://fio.readthedocs.io/en/latest/fio_doc.html[FIO Documentation]

Usage:

[,console]
----
fio --name benchmark1 --directory=/lus/aiholus1/disk/ccarlson/ --group_reporting --rw=read --size=16g --iodepth=128 --blocksize=1024k --direct=1 --numjobs=128 --ioengine=libaio | tee results_max2.out
----

== IOR

Documentation:

* https://wiki.lustre.org/IOR[IOR Documentation]
* https://wiki.lustre.org/IOR#Download_and_Compile_IOR[Download and Compile IOR]
* https://ior.readthedocs.io/en/latest/userDoc/options.html[IOR Command Options]

=== IOR Installation

* https://ior.readthedocs.io/en/latest/userDoc/install.html[`ior` Installation Documentation]

Stop your firewall, this can prevent openmpi communication:

[,bash]
----
systemctl stop firewalld
setenforce 0
----

Install openmpi for your distribution:

* https://docs.open-mpi.org/en/v5.0.x/installing-open-mpi/quickstart.html[Installing OpenMPI Quickstart]

Clone the `ior` repo:

[,bash]
----
git clone https://github.com/hpc/ior
cd ior/
----

Next, bootstrap, configure and make the IOR software:

[,bash]
----
./bootstrap
./configure
make
----

Add the built `ior` binary to your `PATH` variable:

[,bash]
----
export PATH="$PATH:$HOME/ior/src/ior"
----

=== Usage

1. Login to one of the compute nodes as the benchmark user
2. Create a host file for the `mpirun` command, containing the list of Lustre clients that will be used for the benchmark. Each line in the file represents a machine and the number of slots (usually equal to the number of CPU cores). For example:
+
[,bash]
----
for i in $(seq -f "%02g" 1 4); do
  echo "n"$i" slots=128"
done > $HOME/hostfile
----
+
This results in a file like the following:
+
----
n01 slots=128
n02 slots=128
n03 slots=128
n04 slots=128
----
+
* The first column of the host file contains the name of the nodes. This can also be an IP address if the /etc/hosts file or DNS is not set up.
* The second column is used to represent the number of CPU cores.

3. Run a quick test using `mpirun` to launch the benchmark and verify that the environment is set up correctly. For example:
+
[,bash]
----
mpirun --hostfile $HOME/hostfile --map-by node -np $(cat $HOME/hostfile | wc -l) hostname
----

If this is working, you can move on to using the IOR tool. I use the following `benchmark.sh` script to make benchmarks easier 
to execute by just changing some variables:

[,bash]
----
#!/bin/bash

IOR_BIN="/home/ccarlson/ior/src/ior"
MACHINE_FILE="machinefile.txt"
TOTAL_HOSTS=$(cat $MACHINE_FILE | wc -l)
TOTAL_SLOTS=$(( $TOTAL_HOSTS * 128 ))
BLOCKSIZE_PER_TASK="16g"
TRANSFER_SIZES="64m"
TEST_DIRECTORY="/mnt/cstor1/ccarlson"
TEST_FILE="testfile"

set -ex

# Sequential Write
function seq_write {
  TRANSFER_SIZE=$1
  mpirun --allow-run-as-root --machinefile $MACHINE_FILE -np $TOTAL_SLOTS --map-by "slot" \
    $IOR_BIN -v -F --posix.odirect -C -t $TRANSFER_SIZE -b $BLOCKSIZE_PER_TASK -w -k -o $TEST_DIRECTORY/$TEST_FILE \
    > seq_write_$TRANSFER_SIZE.out
}

# Random Write
function rand_write {
  TRANSFER_SIZE=$1
  mpirun --allow-run-as-root --machinefile $MACHINE_FILE -np $TOTAL_SLOTS --map-by "slot" \
    $IOR_BIN -v -F --posix.odirect -C -t $TRANSFER_SIZE -b $BLOCKSIZE_PER_TASK -w -z -k -o $TEST_DIRECTORY/$TEST_FILE \
    > rand_write_$TRANSFER_SIZE.out
}

# Sequential Read
function seq_read {
  TRANSFER_SIZE=$1
  mpirun --allow-run-as-root --machinefile $MACHINE_FILE -np $TOTAL_SLOTS --map-by "slot" \
    $IOR_BIN -v -F --posix.odirect -C -t $TRANSFER_SIZE -b $BLOCKSIZE_PER_TASK -r -k -o $TEST_DIRECTORY/$TEST_FILE \
    > seq_read_$TRANSFER_SIZE.out
}

# Random Read
function rand_read {
  TRANSFER_SIZE=$1
  mpirun --allow-run-as-root --machinefile $MACHINE_FILE -np $TOTAL_SLOTS --map-by "slot" \
    $IOR_BIN -v -F --posix.odirect -C -t $TRANSFER_SIZE -b $BLOCKSIZE_PER_TASK -r -z -k -o $TEST_DIRECTORY/$TEST_FILE \
    > rand_read_$TRANSFER_SIZE.out
}

for TRANSFER_SIZE in $TRANSFER_SIZES; do
  echo -e "\nRunning benchmark with transfer size $TRANSFER_SIZE\n"
  seq_write $TRANSFER_SIZE
  seq_read $TRANSFER_SIZE
  rand_write $TRANSFER_SIZE
  rand_read $TRANSFER_SIZE
done
----
